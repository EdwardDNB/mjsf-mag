# Використання Vue composable

У контексті додатків Vue композиційна функція — це функція, яка використовує композиційний API Vue для інкапсуляції
та повторного використання логіки зі станом.
Під час створення фронтенд додатків нам часто потрібно повторно використовувати логіку для типових завдань.
Наприклад, може знадобитися форматування дати в багатьох місцях. Ця функція форматування інкапсулює
логіку без стану: вона приймає деякий вхід і негайно повертає очікуваний результат.
Існує багато бібліотек для повторного використання логіки без стану, наприклад lodash і date-fns та інші.
Навпаки, логіка збереження стану передбачає керування станом, який змінюється з часом.
Простим прикладом може бути відстеження поточної позиції миші на сторінці. У реальних сценаріях
це також може бути складніша логіка, наприклад жести дотиком або статус підключення до бази даних.

_Приклад:_

```javascript
// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'

// за конвенцією, назви композиційних функцій починаються з "use" (англ. — використовувати)
export function useMouse() {
  // стан, інкапсульований і керований композиційною функцією
  const x = ref(0)
  const y = ref(0)

  // композиційна функція може оновлювати свій керований стан з часом.
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }

  // композиційна функція також може підключитися до свого компонента-власника
  // життєвий цикл для налаштування та демонтажу побічних ефектів.
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))

  // відкрити керований стан як значення, що повертається
  return { x, y }
}
```

І ось як це можна використовувати в компонентах:

```vue
<script setup>
  import { useMouse } from './mouse.js'
  const { x, y } = useMouse()
</script>

<template>Координати миші: {{ x }}, {{ y }}</template>
```

Згідно Конвенції та найкращі практикиами при іменуванні композиційних функцій використовують правила верблюжого регістру, які починаються з "use".

Композиційна функція може приймати референції або геттери в якості аргументів, навіть якщо вона не покладається на них для реактивності. Якщо ви пишете композиційну функцію, яка може використовуватися іншими розробниками, буде гарною ідеєю розглянути випадок, коли вхідні аргументи є референціями або геттерами замість необроблених значень. Допоміжна функція toValue() стане в пригоді для цієї мети:

```javascript
import { toValue } from 'vue'

function useFeature(maybeRefOrGetter) {
  // якщо maybeRefOrGetter справді є референцією або геттером,
  // буде повернено його нормалізоване значення.
  // Інакше воно буде повернуте як є
  const value = toValue(maybeRefOrGetter)
}
```

Якщо ваша композиційна функція створює реактивні ефекти, коли вхідний аргумент є референцією або геттером, переконайтеся, що ви явно спостерігаєте за посиланням / геттером за допомогою watch(), або викликаєте toValue() всередині watchEffect(), щоб воно належним чином відстежувалося.
Згідно з конвенцією, рекомендується, щоб композиційні функції завжди повертали звичайний нереактивний об’єкт, що містить кілька референцій. Це дозволяє його деструктурувати на компоненти, зберігаючи реакційну здатність:
```javascript
// x і y є референціями
const { x, y } = useMouse()
```
Повернення реактивного об'єкта з композиційної функції призведе до того, що такі деструктуризовані дані втратять зв'язок реактивності зі станом всередині композиційної функції, тоді як референції збережуть цей зв'язок.

### Обмеження при використанні

**Composables** слід викликати лише в `<script setup>` або `setup()`. У цьому контексті їх також слід викликати синхронно.
У деяких випадках ви також можете викликати їх у хуках життєвого циклу, наприклад onMounted().
Ці обмеження важливі, оскільки це контексти, де Vue може визначити поточний активний екземпляр компонента.
Доступ до екземпляра активного компонента необхідний для того, щоб:
- мати можливысть зареєструвати хуки життєвого циклу.
- до нього можна прив'язати обчислювані властивості та спостерігачі, щоб їх можна було видалити, коли екземпляр відмонтовано, щоб запобігти джерелам витоку пам'яті.
